#!/usr/bin/env python3
"""
MCP Server for running pikru compliance tests.

Provides a tool to run a single pikchr test, comparing C and Rust implementations,
and returns:
- Side-by-side rendered PNGs
- Color diff image showing differences
- SSIM score for visual similarity
- Element counts and bounding box comparison
- Text content comparison
"""

import io
import logging
import re
import subprocess
import sys
from pathlib import Path
from xml.etree import ElementTree as ET

# Configure logging to stderr (stdout is reserved for MCP protocol)
logging.basicConfig(level=logging.INFO, stream=sys.stderr, format='%(message)s')
logger = logging.getLogger(__name__)

try:
    from mcp.server.fastmcp import FastMCP, Image as MCPImage
except ImportError:
    logger.error("mcp package not installed. Run: pip install mcp")
    sys.exit(1)

try:
    from PIL import Image as PILImage, ImageDraw
except ImportError:
    logger.error("Pillow not installed. Run: pip install Pillow")
    sys.exit(1)

try:
    import numpy as np
    from skimage.metrics import structural_similarity as ssim
    HAS_SKIMAGE = True
except ImportError:
    HAS_SKIMAGE = False
    logger.warning("scikit-image not installed. SSIM calculation will be unavailable. Run: pip install scikit-image")

# Initialize FastMCP server
mcp = FastMCP("pikru-test")

# Project paths
PROJECT_ROOT = Path(__file__).parent.parent
TESTS_DIR = PROJECT_ROOT / "vendor" / "pikchr-c" / "tests"
C_PIKCHR = PROJECT_ROOT / "vendor" / "pikchr-c" / "pikchr"
DEBUG_SVG_DIR = PROJECT_ROOT / "debug-svg"


def run_c_pikchr(source: str) -> tuple[str, bool]:
    """Run the C pikchr implementation and return (output, is_error)."""
    try:
        result = subprocess.run(
            [str(C_PIKCHR), "--svg-only", "/dev/stdin"],
            input=source.encode(),
            capture_output=True,
            timeout=10
        )
        output = result.stdout.decode()
        is_error = "ERROR:" in output or result.returncode != 0
        return output, is_error
    except subprocess.TimeoutExpired:
        return "ERROR: C pikchr timed out", True
    except Exception as e:
        return f"ERROR: Failed to run C pikchr: {e}", True


def run_rust_pikchr(source: str) -> tuple[str, bool]:
    """Run the Rust pikchr implementation via the library."""
    try:
        # Use cargo to run a simple test that outputs SVG
        # We'll create a temp file and use cargo test infrastructure
        result = subprocess.run(
            ["cargo", "run", "-p", "pikru", "--example", "render", "--"],
            input=source.encode(),
            capture_output=True,
            timeout=30,
            cwd=str(PROJECT_ROOT)
        )
        if result.returncode != 0:
            stderr = result.stderr.decode()
            # Try alternative: just use the library directly via Python bindings
            # For now, fall back to reading pre-generated SVG if available
            return f"ERROR: {stderr}", True
        output = result.stdout.decode()
        return output, False
    except subprocess.TimeoutExpired:
        return "ERROR: Rust pikchr timed out", True
    except Exception as e:
        return f"ERROR: Failed to run Rust pikchr: {e}", True


def get_rust_svg_from_debug(test_name: str) -> tuple[str, bool]:
    """Get Rust SVG from debug-svg directory (pre-generated by cargo xtask)."""
    svg_file = DEBUG_SVG_DIR / f"{test_name}-rust.svg"
    if svg_file.exists():
        return svg_file.read_text(), False
    return "ERROR: No pre-generated Rust SVG found. Run 'cargo xtask compare-html' first.", True


def get_c_svg_from_debug(test_name: str) -> tuple[str, bool]:
    """Get C SVG from debug-svg directory (pre-generated by cargo xtask)."""
    svg_file = DEBUG_SVG_DIR / f"{test_name}-c.svg"
    if svg_file.exists():
        return svg_file.read_text(), False
    return "ERROR: No pre-generated C SVG found. Run 'cargo xtask compare-html' first.", True


def extract_svg(output: str) -> str | None:
    """Extract SVG from output, handling print statements before SVG."""
    if "<svg" in output:
        start = output.find("<svg")
        end = output.rfind("</svg>")
        if end != -1:
            return output[start:end + 6]
    if "<Svg" in output:
        start = output.find("<Svg")
        end = output.rfind("</Svg>")
        if end != -1:
            return output[start:end + 6]
    return None


# Maximum dimensions for output images
MAX_IMAGE_WIDTH = 800
MAX_IMAGE_HEIGHT = 400


def svg_to_png(svg_content: str, width: int = 300) -> bytes | None:
    """Convert SVG to PNG bytes using rsvg-convert."""
    if not svg_content:
        return None
    try:
        result = subprocess.run(
            ["rsvg-convert", "-w", str(width), "-f", "png"],
            input=svg_content.encode(),
            capture_output=True,
            timeout=10
        )
        if result.returncode == 0:
            return result.stdout
        logger.error(f"rsvg-convert failed: {result.stderr.decode()}")
        return None
    except Exception as e:
        logger.error(f"SVG to PNG conversion failed: {e}")
        return None


def create_side_by_side(c_png: bytes | None, rust_png: bytes | None,
                        c_error: str | None = None, rust_error: str | None = None) -> bytes:
    """Create a side-by-side comparison image, limited to MAX_IMAGE_WIDTH x MAX_IMAGE_HEIGHT."""
    placeholder_width = 300
    placeholder_height = 200

    if c_png:
        c_img = PILImage.open(io.BytesIO(c_png)).convert("RGBA")
    else:
        c_img = PILImage.new("RGBA", (placeholder_width, placeholder_height), (255, 200, 200, 255))
        draw = ImageDraw.Draw(c_img)
        error_text = c_error[:50] if c_error else "No SVG"
        draw.text((10, placeholder_height // 2), error_text, fill=(128, 0, 0))

    if rust_png:
        rust_img = PILImage.open(io.BytesIO(rust_png)).convert("RGBA")
    else:
        rust_img = PILImage.new("RGBA", (placeholder_width, placeholder_height), (255, 200, 200, 255))
        draw = ImageDraw.Draw(rust_img)
        error_text = rust_error[:50] if rust_error else "No SVG"
        draw.text((10, placeholder_height // 2), error_text, fill=(128, 0, 0))

    # Match heights
    max_height = max(c_img.height, rust_img.height)
    if c_img.height != max_height:
        ratio = max_height / c_img.height
        c_img = c_img.resize((int(c_img.width * ratio), max_height), PILImage.Resampling.LANCZOS)
    if rust_img.height != max_height:
        ratio = max_height / rust_img.height
        rust_img = rust_img.resize((int(rust_img.width * ratio), max_height), PILImage.Resampling.LANCZOS)

    label_height = 25
    gap = 10
    total_width = c_img.width + gap + rust_img.width
    total_height = max_height + label_height

    # Scale down if exceeds max dimensions
    if total_width > MAX_IMAGE_WIDTH or total_height > MAX_IMAGE_HEIGHT:
        scale = min(MAX_IMAGE_WIDTH / total_width, MAX_IMAGE_HEIGHT / total_height)
        new_c_width = int(c_img.width * scale)
        new_rust_width = int(rust_img.width * scale)
        new_height = int(max_height * scale)
        c_img = c_img.resize((new_c_width, new_height), PILImage.Resampling.LANCZOS)
        rust_img = rust_img.resize((new_rust_width, new_height), PILImage.Resampling.LANCZOS)
        gap = int(gap * scale)
        label_height = int(label_height * scale)
        total_width = c_img.width + gap + rust_img.width
        total_height = new_height + label_height

    combined = PILImage.new("RGBA", (total_width, total_height), (255, 255, 255, 255))

    draw = ImageDraw.Draw(combined)
    draw.rectangle([(0, 0), (c_img.width, label_height)], fill=(59, 130, 246))
    draw.text((5, 2), "C pikchr", fill=(255, 255, 255))
    draw.rectangle([(c_img.width + gap, 0), (total_width, label_height)], fill=(249, 115, 22))
    draw.text((c_img.width + gap + 5, 2), "Rust pikchr", fill=(255, 255, 255))

    combined.paste(c_img, (0, label_height))
    combined.paste(rust_img, (c_img.width + gap, label_height))

    output = io.BytesIO()
    combined.save(output, format="PNG")
    return output.getvalue()


def create_diff_image(c_png: bytes | None, rust_png: bytes | None) -> bytes | None:
    """Create a color diff image showing differences, limited to MAX_IMAGE_WIDTH x MAX_IMAGE_HEIGHT."""
    if not c_png or not rust_png:
        return None

    try:
        c_img = PILImage.open(io.BytesIO(c_png)).convert("RGBA")
        rust_img = PILImage.open(io.BytesIO(rust_png)).convert("RGBA")

        width = max(c_img.width, rust_img.width)
        height = max(c_img.height, rust_img.height)

        c_img = c_img.resize((width, height), PILImage.Resampling.LANCZOS)
        rust_img = rust_img.resize((width, height), PILImage.Resampling.LANCZOS)

        diff = PILImage.new("RGBA", (width, height), (255, 255, 255, 255))

        c_data = c_img.load()
        rust_data = rust_img.load()
        diff_data = diff.load()

        for y in range(height):
            for x in range(width):
                c_pixel = c_data[x, y]
                rust_pixel = rust_data[x, y]

                c_gray = (c_pixel[0] + c_pixel[1] + c_pixel[2]) / 3
                rust_gray = (rust_pixel[0] + rust_pixel[1] + rust_pixel[2]) / 3

                c_present = c_gray < 250 and c_pixel[3] > 128
                rust_present = rust_gray < 250 and rust_pixel[3] > 128

                if c_present and rust_present:
                    diff_data[x, y] = (100, 150, 100, 255)  # Green - both
                elif c_present:
                    diff_data[x, y] = (59, 130, 246, 255)  # Blue - C only
                elif rust_present:
                    diff_data[x, y] = (249, 115, 22, 255)  # Orange - Rust only
                else:
                    diff_data[x, y] = (255, 255, 255, 255)  # White - neither

        legend_height = 30
        final_width = width
        final_height = height + legend_height

        # Scale down if exceeds max dimensions
        if final_width > MAX_IMAGE_WIDTH or final_height > MAX_IMAGE_HEIGHT:
            scale = min(MAX_IMAGE_WIDTH / final_width, MAX_IMAGE_HEIGHT / final_height)
            new_width = int(width * scale)
            new_height = int(height * scale)
            diff = diff.resize((new_width, new_height), PILImage.Resampling.LANCZOS)
            legend_height = int(legend_height * scale)
            final_width = new_width
            final_height = new_height + legend_height

        final = PILImage.new("RGBA", (final_width, final_height), (255, 255, 255, 255))
        draw = ImageDraw.Draw(final)

        box_size = 12
        draw.rectangle([(10, 8), (10 + box_size, 8 + box_size)], fill=(59, 130, 246))
        draw.text((25, 8), "C only", fill=(0, 0, 0))

        draw.rectangle([(90, 8), (90 + box_size, 8 + box_size)], fill=(249, 115, 22))
        draw.text((105, 8), "Rust only", fill=(0, 0, 0))

        draw.rectangle([(180, 8), (180 + box_size, 8 + box_size)], fill=(100, 150, 100))
        draw.text((195, 8), "Both", fill=(0, 0, 0))

        final.paste(diff, (0, legend_height))

        output = io.BytesIO()
        final.save(output, format="PNG")
        return output.getvalue()
    except Exception as e:
        logger.error(f"Failed to create diff image: {e}")
        return None


def get_available_tests() -> list[str]:
    """Get list of available test names."""
    if not TESTS_DIR.exists():
        return []
    return sorted([f.stem for f in TESTS_DIR.glob("*.pikchr")])


def run_rust_test(test_name: str) -> tuple[str, str]:
    """
    Run the actual Rust test for this pikchr file and return (status, diff_output).

    This uses the same structural SVG diff logic as `cargo test`.
    Returns: tuple of (status, diff_output) where:
        - status: 'match', 'mismatch', 'rust_error', 'c_error', etc.
        - diff_output: the structural diff output from the test (includes confusables explanation)
    """
    try:
        # Run cargo test for just this specific test file
        result = subprocess.run(
            ["cargo", "test", f"{test_name}.pikchr", "--", "--nocapture"],
            capture_output=True,
            timeout=60,
            cwd=str(PROJECT_ROOT)
        )

        stderr = result.stderr.decode()
        stdout = result.stdout.decode()
        combined = stderr + stdout

        # Extract the diff output - everything after "SVG mismatch for" until "note:" or end
        diff_output = ""
        if "SVG mismatch" in combined:
            # Find the start of the diff
            start_idx = combined.find("SVG mismatch for")
            if start_idx != -1:
                # Find where the diff ends (at "note:" or "failures:")
                end_idx = combined.find("\nnote:", start_idx)
                if end_idx == -1:
                    end_idx = combined.find("\nfailures:", start_idx)
                if end_idx == -1:
                    end_idx = len(combined)
                diff_output = combined[start_idx:end_idx].strip()

        if result.returncode == 0:
            return ("match", "")
        else:
            if "Rust implementation failed but C succeeded" in combined:
                return ("rust_error", diff_output or combined)
            elif "C pikchr produced error but Rust succeeded" in combined:
                return ("c_error", diff_output or combined)
            elif "Both implementations errored" in combined:
                return ("both_error", diff_output or combined)
            elif "SVG mismatch" in combined:
                return ("mismatch", diff_output)
            elif "Parse error" in combined:
                return ("parse_error", diff_output or combined)
            else:
                return ("mismatch", diff_output or combined)
    except subprocess.TimeoutExpired:
        return ("timeout", "Test timed out")
    except Exception as e:
        logger.error(f"Failed to run Rust test: {e}")
        return ("test_error", str(e))


def calculate_ssim(c_png: bytes | None, rust_png: bytes | None) -> float | None:
    """Calculate SSIM between two PNG images. Returns value between 0 and 1."""
    if not HAS_SKIMAGE or not c_png or not rust_png:
        return None

    try:
        c_img = PILImage.open(io.BytesIO(c_png)).convert("L")  # Grayscale
        rust_img = PILImage.open(io.BytesIO(rust_png)).convert("L")

        # Resize to same dimensions
        width = max(c_img.width, rust_img.width)
        height = max(c_img.height, rust_img.height)
        c_img = c_img.resize((width, height), PILImage.Resampling.LANCZOS)
        rust_img = rust_img.resize((width, height), PILImage.Resampling.LANCZOS)

        c_array = np.array(c_img)
        rust_array = np.array(rust_img)

        score = ssim(c_array, rust_array)
        return round(score, 4)
    except Exception as e:
        logger.error(f"SSIM calculation failed: {e}")
        return None


def extract_viewbox(svg: str) -> dict | None:
    """Extract viewBox dimensions from SVG."""
    # Try viewBox attribute
    match = re.search(r'viewBox=["\']([^"\']+)["\']', svg)
    if match:
        parts = match.group(1).split()
        if len(parts) == 4:
            return {
                "x": float(parts[0]),
                "y": float(parts[1]),
                "width": float(parts[2]),
                "height": float(parts[3])
            }

    # Try width/height attributes
    width_match = re.search(r'width=["\']([0-9.]+)', svg)
    height_match = re.search(r'height=["\']([0-9.]+)', svg)
    if width_match and height_match:
        return {
            "x": 0,
            "y": 0,
            "width": float(width_match.group(1)),
            "height": float(height_match.group(1))
        }
    return None


def count_svg_elements(svg: str) -> dict:
    """Count different element types in SVG."""
    counts = {
        "circle": 0,
        "ellipse": 0,
        "line": 0,
        "path": 0,
        "polygon": 0,
        "polyline": 0,
        "rect": 0,
        "text": 0,
    }

    try:
        # Clean up namespace for parsing
        svg_clean = re.sub(r'xmlns=["\'][^"\']*["\']', '', svg)
        root = ET.fromstring(svg_clean)

        def count_recursive(elem):
            tag = elem.tag.split('}')[-1].lower()  # Remove namespace
            if tag in counts:
                counts[tag] += 1
            for child in elem:
                count_recursive(child)

        count_recursive(root)
    except ET.ParseError as e:
        logger.error(f"XML parse error in element counting: {e}")

    # Filter to non-zero counts
    return {k: v for k, v in counts.items() if v > 0}


def extract_text_content(svg: str) -> list[str]:
    """Extract all text content from SVG text elements."""
    texts = []
    try:
        svg_clean = re.sub(r'xmlns=["\'][^"\']*["\']', '', svg)
        root = ET.fromstring(svg_clean)

        def find_text(elem):
            tag = elem.tag.split('}')[-1].lower()
            if tag == "text":
                # Get text from element and all children (tspan, etc.)
                text = ''.join(elem.itertext()).strip()
                if text:
                    texts.append(text)
            for child in elem:
                find_text(child)

        find_text(root)
    except ET.ParseError as e:
        logger.error(f"XML parse error in text extraction: {e}")

    return texts


def count_diff_pixels(c_png: bytes | None, rust_png: bytes | None) -> dict | None:
    """Count pixels by category in diff: c_only, rust_only, both, neither."""
    if not c_png or not rust_png:
        return None

    try:
        c_img = PILImage.open(io.BytesIO(c_png)).convert("RGBA")
        rust_img = PILImage.open(io.BytesIO(rust_png)).convert("RGBA")

        width = max(c_img.width, rust_img.width)
        height = max(c_img.height, rust_img.height)

        c_img = c_img.resize((width, height), PILImage.Resampling.LANCZOS)
        rust_img = rust_img.resize((width, height), PILImage.Resampling.LANCZOS)

        c_data = c_img.load()
        rust_data = rust_img.load()

        counts = {"c_only": 0, "rust_only": 0, "both": 0, "neither": 0}

        for y in range(height):
            for x in range(width):
                c_pixel = c_data[x, y]
                rust_pixel = rust_data[x, y]

                c_gray = (c_pixel[0] + c_pixel[1] + c_pixel[2]) / 3
                rust_gray = (rust_pixel[0] + rust_pixel[1] + rust_pixel[2]) / 3

                c_present = c_gray < 250 and c_pixel[3] > 128
                rust_present = rust_gray < 250 and rust_pixel[3] > 128

                if c_present and rust_present:
                    counts["both"] += 1
                elif c_present:
                    counts["c_only"] += 1
                elif rust_present:
                    counts["rust_only"] += 1
                else:
                    counts["neither"] += 1

        total_content = counts["c_only"] + counts["rust_only"] + counts["both"]
        if total_content > 0:
            counts["overlap_pct"] = round(100 * counts["both"] / total_content, 1)
        else:
            counts["overlap_pct"] = 100.0

        return counts
    except Exception as e:
        logger.error(f"Diff pixel counting failed: {e}")
        return None


@mcp.tool()
def run_pikru_test(test_name: str) -> list:
    """
    Run a single pikru compliance test comparing C and Rust implementations.

    Args:
        test_name: Name of the test (e.g., 'test01', 'autochop02').
                   Don't include .pikchr extension.

    Returns:
        A dictionary containing:
        - test_name: The test that was run
        - status: 'match' or 'mismatch'
        - source: The pikchr source code
        - c_output: C implementation output
        - rust_output: Rust implementation output
        - side_by_side_png: Base64-encoded side-by-side comparison PNG
        - diff_png: Base64-encoded color diff PNG (if both succeeded)
        - svg_diff: Text description of SVG differences
    """
    # Find the test file
    test_file = TESTS_DIR / f"{test_name}.pikchr"
    if not test_file.exists():
        available = get_available_tests()
        return [{
            "error": f"Test '{test_name}' not found",
            "available_tests": available[:20],
            "hint": f"Use one of: {', '.join(available[:10])}..."
        }]

    # Read source
    source = test_file.read_text()

    # Try to get pre-generated SVGs from debug-svg (faster, more reliable)
    c_svg_content, c_is_error = get_c_svg_from_debug(test_name)
    rust_svg_content, rust_is_error = get_rust_svg_from_debug(test_name)

    # If debug SVGs don't exist, run live
    if c_is_error:
        c_output, c_is_error = run_c_pikchr(source)
        c_svg = extract_svg(c_output) if not c_is_error else None
    else:
        c_output = c_svg_content
        c_svg = c_svg_content

    if rust_is_error:
        rust_output = rust_svg_content  # Contains error message
        rust_svg = None
    else:
        rust_output = rust_svg_content
        rust_svg = rust_svg_content

    # Convert to PNGs
    c_png = svg_to_png(c_svg) if c_svg else None
    rust_png = svg_to_png(rust_svg) if rust_svg else None

    # Create comparison images
    side_by_side_bytes = create_side_by_side(
        c_png, rust_png,
        c_error=c_output if c_is_error else None,
        rust_error=rust_output if rust_is_error else None
    )
    diff_bytes = create_diff_image(c_png, rust_png)

    # Calculate SSIM
    ssim_score = calculate_ssim(c_png, rust_png)

    # Extract bounding boxes
    c_viewbox = extract_viewbox(c_svg) if c_svg else None
    rust_viewbox = extract_viewbox(rust_svg) if rust_svg else None

    # Count elements
    c_elements = count_svg_elements(c_svg) if c_svg else {}
    rust_elements = count_svg_elements(rust_svg) if rust_svg else {}

    # Extract text content
    c_texts = extract_text_content(c_svg) if c_svg else []
    rust_texts = extract_text_content(rust_svg) if rust_svg else []

    # Count diff pixels
    pixel_counts = count_diff_pixels(c_png, rust_png)

    # Determine match status by running the actual Rust test
    # This is the source of truth - same logic as `cargo test`
    status, svg_diff = run_rust_test(test_name)

    # Build comparison details
    comparison = {
        "ssim": ssim_score,
        "pixel_diff": pixel_counts,
        "viewbox": {
            "c": c_viewbox,
            "rust": rust_viewbox,
            "match": c_viewbox == rust_viewbox if c_viewbox and rust_viewbox else None
        },
        "elements": {
            "c": c_elements,
            "rust": rust_elements,
            "match": c_elements == rust_elements
        },
        "text": {
            "c": c_texts,
            "rust": rust_texts,
            "match": c_texts == rust_texts
        }
    }

    # Build response with proper MCP Image content blocks
    result = []

    # Add text info
    result.append({
        "test_name": test_name,
        "status": status,
        "source": source,
        "comparison": comparison,
        "svg_diff": svg_diff if svg_diff else None,
    })

    # Add side-by-side image as proper MCP Image
    if side_by_side_bytes:
        result.append(MCPImage(data=side_by_side_bytes, format="png"))

    # Add diff image as proper MCP Image
    if diff_bytes:
        result.append(MCPImage(data=diff_bytes, format="png"))

    return result


@mcp.tool()
def list_pikru_tests() -> dict:
    """
    List all available pikru compliance tests.

    Returns:
        A dictionary with test names grouped by category.
    """
    tests = get_available_tests()

    numbered = [t for t in tests if t.startswith("test")]
    autochop = [t for t in tests if t.startswith("autochop")]
    other = [t for t in tests if not t.startswith("test") and not t.startswith("autochop")]

    return {
        "total": len(tests),
        "numbered_tests": numbered,
        "autochop_tests": autochop,
        "other_tests": other
    }


def main():
    """Run the MCP server."""
    logger.info(f"Starting pikru-test MCP server")
    logger.info(f"Project root: {PROJECT_ROOT}")
    logger.info(f"Tests dir: {TESTS_DIR}")
    logger.info(f"C pikchr: {C_PIKCHR}")
    mcp.run(transport='stdio')


if __name__ == "__main__":
    main()
